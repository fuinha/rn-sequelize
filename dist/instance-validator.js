'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

const _ = require('lodash');

const Utils = require('./utils');

const sequelizeError = require('./errors');

const Promise = require('./promise');

const DataTypes = require('./data-types');

const BelongsTo = require('./associations/belongs-to');

const validator = require('./utils/validator-extras').validator;
/**
 * Instance Validator.
 *
 * @param {Instance} modelInstance The model instance.
 * @param {Object} options A dictionary with options.
 *
 * @private
 */


let InstanceValidator =
/*#__PURE__*/
function () {
  function InstanceValidator(modelInstance, options) {
    _classCallCheck(this, InstanceValidator);

    options = _.clone(options) || {};

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } // assign defined and default options


    this.options = _.defaults(options, {
      skip: [],
      hooks: true
    });
    this.modelInstance = modelInstance;
    /**
     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
     * @name validator
     * @private
     */

    this.validator = validator;
    /**
     *  All errors will be stored here from the validations.
     *
     * @type {Array} Will contain keys that correspond to attributes which will
     *   be Arrays of Errors.
     * @private
     */

    this.errors = [];
    /**
     * @type {boolean} Indicates if validations are in progress
     * @private
     */

    this.inProgress = false;
  }
  /**
   * The main entry point for the Validation module, invoke to start the dance.
   *
   * @returns {Promise}
   * @private
   */


  _createClass(InstanceValidator, [{
    key: "_validate",
    value: function _validate() {
      if (this.inProgress) throw new Error('Validations already in progress.');
      this.inProgress = true;
      return Promise.all([this._perAttributeValidators().reflect(), this._customValidators().reflect()]).then(() => {
        if (this.errors.length) {
          throw new sequelizeError.ValidationError(null, this.errors);
        }
      });
    }
    /**
     * Invoke the Validation sequence and run validation hooks if defined
     *   - Before Validation Model Hooks
     *   - Validation
     *   - On validation success: After Validation Model Hooks
     *   - On validation failure: Validation Failed Model Hooks
     *
     * @returns {Promise}
     * @private
     */

  }, {
    key: "validate",
    value: function validate() {
      return this.options.hooks ? this._validateAndRunHooks() : this._validate();
    }
    /**
     * Invoke the Validation sequence and run hooks
     *   - Before Validation Model Hooks
     *   - Validation
     *   - On validation success: After Validation Model Hooks
     *   - On validation failure: Validation Failed Model Hooks
     *
     * @returns {Promise}
     * @private
     */

  }, {
    key: "_validateAndRunHooks",
    value: function _validateAndRunHooks() {
      const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
      return runHooks('beforeValidate', this.modelInstance, this.options).then(() => this._validate().catch(error => runHooks('validationFailed', this.modelInstance, this.options, error).then(newError => {
        throw newError || error;
      }))).then(() => runHooks('afterValidate', this.modelInstance, this.options)).return(this.modelInstance);
    }
    /**
     * Will run all the validators defined per attribute (built-in validators and custom validators)
     *
     * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().
     * @private
     */

  }, {
    key: "_perAttributeValidators",
    value: function _perAttributeValidators() {
      // promisify all attribute invocations
      const validators = [];

      _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
        if (this.options.skip.includes(field)) {
          return;
        }

        const value = this.modelInstance.dataValues[field];

        if (value instanceof Utils.SequelizeMethod) {
          return;
        }

        if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
          // perform validations based on schema
          this._validateSchema(rawAttribute, field, value);
        }

        if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
          validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull).reflect());
        }
      });

      return Promise.all(validators);
    }
    /**
     * Will run all the custom validators defined in the model's options.
     *
     * @returns {Promise<Array.<Promise.PromiseInspection>>} A promise from .reflect().
     * @private
     */

  }, {
    key: "_customValidators",
    value: function _customValidators() {
      const validators = [];

      _.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {
        if (this.options.skip.includes(validatorType)) {
          return;
        }

        const valprom = this._invokeCustomValidator(validator, validatorType) // errors are handled in settling, stub this
        .catch(() => {}).reflect();

        validators.push(valprom);
      });

      return Promise.all(validators);
    }
    /**
     * Validate a single attribute with all the defined built-in validators and custom validators.
     *
     * @private
     *
     * @param {*} value Anything.
     * @param {string} field The field name.
     * @param {boolean} allowNull Whether or not the schema allows null values
     *
     * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.
     */

  }, {
    key: "_singleAttrValidate",
    value: function _singleAttrValidate(value, field, allowNull) {
      // If value is null and allowNull is false, no validators should run (see #9143)
      if ((value === null || value === undefined) && !allowNull) {
        // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.
        return Promise.resolve();
      } // Promisify each validator


      const validators = [];

      _.forIn(this.modelInstance.validators[field], (test, validatorType) => {
        if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {
          // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
          if (typeof test === 'object' && test !== null && test.msg) {
            test = {
              msg: test.msg
            };
          } else if (test === true) {
            test = {};
          }
        } // Custom validators should always run, except if value is null and allowNull is false (see #9143)


        if (typeof test === 'function') {
          validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());
          return;
        } // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).


        if (value === null || value === undefined) {
          return;
        }

        const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field); // errors are handled in settling, stub this


        validatorPromise.catch(() => {});
        validators.push(validatorPromise.reflect());
      });

      return Promise.all(validators).then(results => this._handleReflectedResult(field, value, results));
    }
    /**
     * Prepare and invoke a custom validator.
     *
     * @private
     *
     * @param {Function} validator The custom validator.
     * @param {string} validatorType the custom validator type (name).
     * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute
     * @param {*} optValue value for attribute
     * @param {string} optField field for attribute
     *
     * @returns {Promise} A promise.
     */

  }, {
    key: "_invokeCustomValidator",
    value: function _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {
      let validatorFunction = null; // the validation function to call

      let isAsync = false;
      const validatorArity = validator.length; // check if validator is async and requires a callback

      let asyncArity = 1;
      let errorKey = validatorType;
      let invokeArgs;

      if (optAttrDefined) {
        asyncArity = 2;
        invokeArgs = optValue;
        errorKey = optField;
      }

      if (validatorArity === asyncArity) {
        isAsync = true;
      }

      if (isAsync) {
        if (optAttrDefined) {
          validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));
        } else {
          validatorFunction = Promise.promisify(validator.bind(this.modelInstance));
        }

        return validatorFunction().catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
      }

      return Promise.try(() => validator.call(this.modelInstance, invokeArgs)).catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
    }
    /**
     * Prepare and invoke a build-in validator.
     *
     * @private
     *
     * @param {*} value Anything.
     * @param {*} test The test case.
     * @param {string} validatorType One of known to Sequelize validators.
     * @param {string} field The field that is being validated
     *
     * @returns {Object} An object with specific keys to invoke the validator.
     */

  }, {
    key: "_invokeBuiltinValidator",
    value: function _invokeBuiltinValidator(value, test, validatorType, field) {
      return Promise.try(() => {
        // Cast value as string to pass new Validator.js string requirement
        const valueString = String(value); // check if Validator knows that kind of validation test

        if (typeof validator[validatorType] !== 'function') {
          throw new Error(`Invalid validator function: ${validatorType}`);
        }

        const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

        if (!validator[validatorType](valueString, ...validatorArgs)) {
          throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {
            validatorName: validatorType,
            validatorArgs
          });
        }
      });
    }
    /**
     * Will extract arguments for the validator.
     *
     * @param {*} test The test case.
     * @param {string} validatorType One of known to Sequelize validators.
     * @param {string} field The field that is being validated.
     *
     * @private
     */

  }, {
    key: "_extractValidatorArgs",
    value: function _extractValidatorArgs(test, validatorType, field) {
      let validatorArgs = test.args || test;
      const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

      if (!Array.isArray(validatorArgs)) {
        if (validatorType === 'isImmutable') {
          validatorArgs = [validatorArgs, field, this.modelInstance];
        } else if (isLocalizedValidator || validatorType === 'isIP') {
          validatorArgs = [];
        } else {
          validatorArgs = [validatorArgs];
        }
      } else {
        validatorArgs = validatorArgs.slice(0);
      }

      return validatorArgs;
    }
    /**
     * Will validate a single field against its schema definition (isnull).
     *
     * @param {Object} rawAttribute As defined in the Schema.
     * @param {string} field The field name.
     * @param {*} value anything.
     *
     * @private
     */

  }, {
    key: "_validateSchema",
    value: function _validateSchema(rawAttribute, field, value) {
      if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
        const association = _.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);

        if (!association || !this.modelInstance.get(association.associationAccessor)) {
          const validators = this.modelInstance.validators[field];

          const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

          this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field, value, this.modelInstance, 'is_null'));
        }
      }

      if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
        if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
          this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, 'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field, value, this.modelInstance, 'not_a_string'));
        }
      }
    }
    /**
     * Handles the returned result of a Promise.reflect.
     *
     * If errors are found it populates this.error.
     *
     * @param {string} field The attribute name.
     * @param {string|number} value The data value.
     * @param {Array<Promise.PromiseInspection>} promiseInspections objects.
     *
     * @private
     */

  }, {
    key: "_handleReflectedResult",
    value: function _handleReflectedResult(field, value, promiseInspections) {
      for (const promiseInspection of promiseInspections) {
        if (promiseInspection.isRejected()) {
          const rejection = promiseInspection.error();
          const isBuiltIn = !!rejection.validatorName;

          this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
        }
      }
    }
    /**
     * Signs all errors retaining the original.
     *
     * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.
     * @param {string}        errorKey    - name of invalid attribute.
     * @param {Error|string}  rawError    - The original error.
     * @param {string|number} value       - The data that triggered the error.
     * @param {string}        fnName      - Name of the validator, if any
     * @param {Array}         fnArgs      - Arguments for the validator [function], if any
     *
     * @private
     */

  }, {
    key: "_pushError",
    value: function _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
      const message = rawError.message || rawError || 'Validation error';
      const error = new sequelizeError.ValidationErrorItem(message, 'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : undefined, isBuiltin ? fnArgs : undefined);
      error[InstanceValidator.RAW_KEY_NAME] = rawError;
      this.errors.push(error);
    }
  }]);

  return InstanceValidator;
}();
/**
 * @define {string} The error key for arguments as passed by custom validators
 * @private
 */


InstanceValidator.RAW_KEY_NAME = 'original';
module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanMiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJVdGlscyIsInNlcXVlbGl6ZUVycm9yIiwiUHJvbWlzZSIsIkRhdGFUeXBlcyIsIkJlbG9uZ3NUbyIsInZhbGlkYXRvciIsIkluc3RhbmNlVmFsaWRhdG9yIiwibW9kZWxJbnN0YW5jZSIsIm9wdGlvbnMiLCJjbG9uZSIsImZpZWxkcyIsInNraXAiLCJkaWZmZXJlbmNlIiwiT2JqZWN0Iiwia2V5cyIsImNvbnN0cnVjdG9yIiwicmF3QXR0cmlidXRlcyIsImRlZmF1bHRzIiwiaG9va3MiLCJlcnJvcnMiLCJpblByb2dyZXNzIiwiRXJyb3IiLCJhbGwiLCJfcGVyQXR0cmlidXRlVmFsaWRhdG9ycyIsInJlZmxlY3QiLCJfY3VzdG9tVmFsaWRhdG9ycyIsInRoZW4iLCJsZW5ndGgiLCJWYWxpZGF0aW9uRXJyb3IiLCJfdmFsaWRhdGVBbmRSdW5Ib29rcyIsIl92YWxpZGF0ZSIsInJ1bkhvb2tzIiwiYmluZCIsImNhdGNoIiwiZXJyb3IiLCJuZXdFcnJvciIsInJldHVybiIsInZhbGlkYXRvcnMiLCJmb3JJbiIsInJhd0F0dHJpYnV0ZSIsImZpZWxkIiwiaW5jbHVkZXMiLCJ2YWx1ZSIsImRhdGFWYWx1ZXMiLCJTZXF1ZWxpemVNZXRob2QiLCJfYXV0b0dlbmVyYXRlZCIsImF1dG9JbmNyZW1lbnQiLCJfdmFsaWRhdGVTY2hlbWEiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwdXNoIiwiX3NpbmdsZUF0dHJWYWxpZGF0ZSIsImFsbG93TnVsbCIsImVhY2giLCJfbW9kZWxPcHRpb25zIiwidmFsaWRhdGUiLCJ2YWxpZGF0b3JUeXBlIiwidmFscHJvbSIsIl9pbnZva2VDdXN0b21WYWxpZGF0b3IiLCJ1bmRlZmluZWQiLCJyZXNvbHZlIiwidGVzdCIsIm1zZyIsInZhbGlkYXRvclByb21pc2UiLCJfaW52b2tlQnVpbHRpblZhbGlkYXRvciIsInJlc3VsdHMiLCJfaGFuZGxlUmVmbGVjdGVkUmVzdWx0Iiwib3B0QXR0ckRlZmluZWQiLCJvcHRWYWx1ZSIsIm9wdEZpZWxkIiwidmFsaWRhdG9yRnVuY3Rpb24iLCJpc0FzeW5jIiwidmFsaWRhdG9yQXJpdHkiLCJhc3luY0FyaXR5IiwiZXJyb3JLZXkiLCJpbnZva2VBcmdzIiwicHJvbWlzaWZ5IiwiZSIsIl9wdXNoRXJyb3IiLCJ0cnkiLCJ2YWx1ZVN0cmluZyIsIlN0cmluZyIsInZhbGlkYXRvckFyZ3MiLCJfZXh0cmFjdFZhbGlkYXRvckFyZ3MiLCJhc3NpZ24iLCJ2YWxpZGF0b3JOYW1lIiwiYXJncyIsImlzTG9jYWxpemVkVmFsaWRhdG9yIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJhc3NvY2lhdGlvbiIsInZhbHVlcyIsImFzc29jaWF0aW9ucyIsImZpbmQiLCJmb3JlaWduS2V5IiwiZmllbGROYW1lIiwiZ2V0IiwiYXNzb2NpYXRpb25BY2Nlc3NvciIsImVyck1zZyIsIm5hbWUiLCJWYWxpZGF0aW9uRXJyb3JJdGVtIiwidHlwZSIsIlNUUklORyIsIlRFWFQiLCJDSVRFWFQiLCJpc09iamVjdCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicHJvbWlzZUluc3BlY3Rpb25zIiwicHJvbWlzZUluc3BlY3Rpb24iLCJpc1JlamVjdGVkIiwicmVqZWN0aW9uIiwiaXNCdWlsdEluIiwiaXNCdWlsdGluIiwicmF3RXJyb3IiLCJmbk5hbWUiLCJmbkFyZ3MiLCJtZXNzYWdlIiwiUkFXX0tFWV9OQU1FIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBLE1BQU1BLENBQUMsR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBakI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsU0FBRCxDQUFyQjs7QUFDQSxNQUFNRSxjQUFjLEdBQUdGLE9BQU8sQ0FBQyxVQUFELENBQTlCOztBQUNBLE1BQU1HLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFdB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QW1ILE1BQU0sQ0FBQ0MsT0FBUCxDQUFlcEgsaUJBQWYsR0FBbUNBLGlCQUFuQztBQUNBbUgsTUFBTSxDQUFDQyxPQUFQLENBQWVDLE9BQWYsR0FBeUJySCxpQkFBekIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5jb25zdCBzZXF1ZWxpemVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcclxuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XHJcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8nKTtcclxuY29uc3QgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0b3ItZXh0cmFzJykudmFsaWRhdG9yO1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbmNlIFZhbGlkYXRvci5cclxuICpcclxuICogQHBhcmFtIHtJbnN0YW5jZX0gbW9kZWxJbnN0YW5jZSBUaGUgbW9kZWwgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBJbnN0YW5jZVZhbGlkYXRvciB7XHJcbiAgY29uc3RydWN0b3IobW9kZWxJbnN0YW5jZSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuZmllbGRzICYmICFvcHRpb25zLnNraXApIHtcclxuICAgICAgb3B0aW9ucy5za2lwID0gXy5kaWZmZXJlbmNlKE9iamVjdC5rZXlzKG1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyksIG9wdGlvbnMuZmllbGRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhc3NpZ24gZGVmaW5lZCBhbmQgZGVmYXVsdCBvcHRpb25zXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcclxuICAgICAgc2tpcDogW10sXHJcbiAgICAgIGhvb2tzOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1vZGVsSW5zdGFuY2UgPSBtb2RlbEluc3RhbmNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3NlcyBhIHJlZmVyZW5jZSB0byB2YWxpZGF0b3IuanMuIFRoaXMgYWxsb3dzIHlvdSB0byBhZGQgY3VzdG9tIHZhbGlkYXRpb25zIHVzaW5nIGB2YWxpZGF0b3IuZXh0ZW5kYFxyXG4gICAgICogQG5hbWUgdmFsaWRhdG9yXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBBbGwgZXJyb3JzIHdpbGwgYmUgc3RvcmVkIGhlcmUgZnJvbSB0aGUgdmFsaWRhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0FycmF5fSBXaWxsIGNvbnRhaW4ga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYXR0cmlidXRlcyB3aGljaCB3aWxsXHJcbiAgICAgKiAgIGJlIEFycmF5cyBvZiBFcnJvcnMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IEluZGljYXRlcyBpZiB2YWxpZGF0aW9ucyBhcmUgaW4gcHJvZ3Jlc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBWYWxpZGF0aW9uIG1vZHVsZSwgaW52b2tlIHRvIHN0YXJ0IHRoZSBkYW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuaW5Qcm9ncmVzcykgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0aW9ucyBhbHJlYWR5IGluIHByb2dyZXNzLicpO1xyXG5cclxuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgdGhpcy5fcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpLnJlZmxlY3QoKSxcclxuICAgICAgdGhpcy5fY3VzdG9tVmFsaWRhdG9ycygpLnJlZmxlY3QoKVxyXG4gICAgXSkudGhlbigoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9yKG51bGwsIHRoaXMuZXJyb3JzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgdGhlIFZhbGlkYXRpb24gc2VxdWVuY2UgYW5kIHJ1biB2YWxpZGF0aW9uIGhvb2tzIGlmIGRlZmluZWRcclxuICAgKiAgIC0gQmVmb3JlIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcclxuICAgKiAgIC0gVmFsaWRhdGlvblxyXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIHN1Y2Nlc3M6IEFmdGVyIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcclxuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBmYWlsdXJlOiBWYWxpZGF0aW9uIEZhaWxlZCBNb2RlbCBIb29rc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB2YWxpZGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9va3MgPyB0aGlzLl92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkgOiB0aGlzLl92YWxpZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIHRoZSBWYWxpZGF0aW9uIHNlcXVlbmNlIGFuZCBydW4gaG9va3NcclxuICAgKiAgIC0gQmVmb3JlIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcclxuICAgKiAgIC0gVmFsaWRhdGlvblxyXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIHN1Y2Nlc3M6IEFmdGVyIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcclxuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBmYWlsdXJlOiBWYWxpZGF0aW9uIEZhaWxlZCBNb2RlbCBIb29rc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdmFsaWRhdGVBbmRSdW5Ib29rcygpIHtcclxuICAgIGNvbnN0IHJ1bkhvb2tzID0gdGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLnJ1bkhvb2tzLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcclxuICAgIHJldHVybiBydW5Ib29rcygnYmVmb3JlVmFsaWRhdGUnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucylcclxuICAgICAgLnRoZW4oKCkgPT5cclxuICAgICAgICB0aGlzLl92YWxpZGF0ZSgpXHJcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gcnVuSG9va3MoJ3ZhbGlkYXRpb25GYWlsZWQnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucywgZXJyb3IpXHJcbiAgICAgICAgICAgIC50aGVuKG5ld0Vycm9yID0+IHsgdGhyb3cgbmV3RXJyb3IgfHwgZXJyb3I7IH0pKVxyXG4gICAgICApXHJcbiAgICAgIC50aGVuKCgpID0+IHJ1bkhvb2tzKCdhZnRlclZhbGlkYXRlJywgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpKVxyXG4gICAgICAucmV0dXJuKHRoaXMubW9kZWxJbnN0YW5jZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaWxsIHJ1biBhbGwgdGhlIHZhbGlkYXRvcnMgZGVmaW5lZCBwZXIgYXR0cmlidXRlIChidWlsdC1pbiB2YWxpZGF0b3JzIGFuZCBjdXN0b20gdmFsaWRhdG9ycylcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uPj59IEEgcHJvbWlzZSBmcm9tIC5yZWZsZWN0KCkuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpIHtcclxuICAgIC8vIHByb21pc2lmeSBhbGwgYXR0cmlidXRlIGludm9jYXRpb25zXHJcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XHJcblxyXG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UucmF3QXR0cmlidXRlcywgKHJhd0F0dHJpYnV0ZSwgZmllbGQpID0+IHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKGZpZWxkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1vZGVsSW5zdGFuY2UuZGF0YVZhbHVlc1tmaWVsZF07XHJcblxyXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcmF3QXR0cmlidXRlLl9hdXRvR2VuZXJhdGVkICYmICFyYXdBdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xyXG4gICAgICAgIC8vIHBlcmZvcm0gdmFsaWRhdGlvbnMgYmFzZWQgb24gc2NoZW1hXHJcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzLCBmaWVsZCkpIHtcclxuICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy5fc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgcmF3QXR0cmlidXRlLmFsbG93TnVsbCkucmVmbGVjdCgpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2lsbCBydW4gYWxsIHRoZSBjdXN0b20gdmFsaWRhdG9ycyBkZWZpbmVkIGluIHRoZSBtb2RlbCdzIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheS48UHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbj4+fSBBIHByb21pc2UgZnJvbSAucmVmbGVjdCgpLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2N1c3RvbVZhbGlkYXRvcnMoKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XHJcbiAgICBfLmVhY2godGhpcy5tb2RlbEluc3RhbmNlLl9tb2RlbE9wdGlvbnMudmFsaWRhdGUsICh2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUpID0+IHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKHZhbGlkYXRvclR5cGUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB2YWxwcm9tID0gdGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSlcclxuICAgICAgICAvLyBlcnJvcnMgYXJlIGhhbmRsZWQgaW4gc2V0dGxpbmcsIHN0dWIgdGhpc1xyXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7fSlcclxuICAgICAgICAucmVmbGVjdCgpO1xyXG5cclxuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbHByb20pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYSBzaW5nbGUgYXR0cmlidXRlIHdpdGggYWxsIHRoZSBkZWZpbmVkIGJ1aWx0LWluIHZhbGlkYXRvcnMgYW5kIGN1c3RvbSB2YWxpZGF0b3JzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55dGhpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dOdWxsIFdoZXRoZXIgb3Igbm90IHRoZSBzY2hlbWEgYWxsb3dzIG51bGwgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlLCB3aWxsIGFsd2F5cyByZXNvbHZlLCBhdXRvIHBvcHVsYXRlcyBlcnJvciBvbiB0aGlzLmVycm9yIGxvY2FsIG9iamVjdC5cclxuICAgKi9cclxuICBfc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgYWxsb3dOdWxsKSB7XHJcbiAgICAvLyBJZiB2YWx1ZSBpcyBudWxsIGFuZCBhbGxvd051bGwgaXMgZmFsc2UsIG5vIHZhbGlkYXRvcnMgc2hvdWxkIHJ1biAoc2VlICM5MTQzKVxyXG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSAmJiAhYWxsb3dOdWxsKSB7XHJcbiAgICAgIC8vIFRoZSBzY2hlbWEgdmFsaWRhdG9yIChfdmFsaWRhdGVTY2hlbWEpIGhhcyBhbHJlYWR5IGdlbmVyYXRlZCB0aGUgdmFsaWRhdGlvbiBlcnJvci4gTm90aGluZyB0byBkbyBoZXJlLlxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvbWlzaWZ5IGVhY2ggdmFsaWRhdG9yXHJcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XHJcbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzW2ZpZWxkXSwgKHRlc3QsIHZhbGlkYXRvclR5cGUpID0+IHtcclxuXHJcbiAgICAgIGlmICh2YWxpZGF0b3JUeXBlID09PSAnaXNVcmwnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc1VSTCcgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzRW1haWwnKSB7XHJcbiAgICAgICAgLy8gUHJlc2VydmUgYmFja3dhcmRzIGNvbXBhdC4gVmFsaWRhdG9yLmpzIG5vdyBleHBlY3RzIHRoZSBzZWNvbmQgcGFyYW0gdG8gaXNVUkwgYW5kIGlzRW1haWwgdG8gYmUgYW4gb2JqZWN0XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnb2JqZWN0JyAmJiB0ZXN0ICE9PSBudWxsICYmIHRlc3QubXNnKSB7XHJcbiAgICAgICAgICB0ZXN0ID0ge1xyXG4gICAgICAgICAgICBtc2c6IHRlc3QubXNnXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGVzdCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgdGVzdCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3VzdG9tIHZhbGlkYXRvcnMgc2hvdWxkIGFsd2F5cyBydW4sIGV4Y2VwdCBpZiB2YWx1ZSBpcyBudWxsIGFuZCBhbGxvd051bGwgaXMgZmFsc2UgKHNlZSAjOTE0MylcclxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX2ludm9rZUN1c3RvbVZhbGlkYXRvcih0ZXN0LCB2YWxpZGF0b3JUeXBlLCB0cnVlLCB2YWx1ZSwgZmllbGQpLnJlZmxlY3QoKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB2YWx1ZSBpcyBudWxsLCBidWlsdC1pbiB2YWxpZGF0b3JzIHNob3VsZCBub3QgcnVuIChvbmx5IGN1c3RvbSB2YWxpZGF0b3JzIGhhdmUgdG8gcnVuKSAoc2VlICM5MTM0KS5cclxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHZhbGlkYXRvclByb21pc2UgPSB0aGlzLl9pbnZva2VCdWlsdGluVmFsaWRhdG9yKHZhbHVlLCB0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCk7XHJcbiAgICAgIC8vIGVycm9ycyBhcmUgaGFuZGxlZCBpbiBzZXR0bGluZywgc3R1YiB0aGlzXHJcbiAgICAgIHZhbGlkYXRvclByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xyXG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yUHJvbWlzZS5yZWZsZWN0KCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2VcclxuICAgICAgLmFsbCh2YWxpZGF0b3JzKVxyXG4gICAgICAudGhlbihyZXN1bHRzID0+IHRoaXMuX2hhbmRsZVJlZmxlY3RlZFJlc3VsdChmaWVsZCwgdmFsdWUsIHJlc3VsdHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXBhcmUgYW5kIGludm9rZSBhIGN1c3RvbSB2YWxpZGF0b3IuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsaWRhdG9yIFRoZSBjdXN0b20gdmFsaWRhdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JUeXBlIHRoZSBjdXN0b20gdmFsaWRhdG9yIHR5cGUgKG5hbWUpLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0QXR0ckRlZmluZWQgU2V0IHRvIHRydWUgaWYgY3VzdG9tIHZhbGlkYXRvciB3YXMgZGVmaW5lZCBmcm9tIHRoZSBhdHRyaWJ1dGVcclxuICAgKiBAcGFyYW0geyp9IG9wdFZhbHVlIHZhbHVlIGZvciBhdHRyaWJ1dGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0RmllbGQgZmllbGQgZm9yIGF0dHJpYnV0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZS5cclxuICAgKi9cclxuICBfaW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSwgb3B0QXR0ckRlZmluZWQsIG9wdFZhbHVlLCBvcHRGaWVsZCkge1xyXG4gICAgbGV0IHZhbGlkYXRvckZ1bmN0aW9uID0gbnVsbDsgLy8gdGhlIHZhbGlkYXRpb24gZnVuY3Rpb24gdG8gY2FsbFxyXG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCB2YWxpZGF0b3JBcml0eSA9IHZhbGlkYXRvci5sZW5ndGg7XHJcbiAgICAvLyBjaGVjayBpZiB2YWxpZGF0b3IgaXMgYXN5bmMgYW5kIHJlcXVpcmVzIGEgY2FsbGJhY2tcclxuICAgIGxldCBhc3luY0FyaXR5ID0gMTtcclxuICAgIGxldCBlcnJvcktleSA9IHZhbGlkYXRvclR5cGU7XHJcbiAgICBsZXQgaW52b2tlQXJncztcclxuICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xyXG4gICAgICBhc3luY0FyaXR5ID0gMjtcclxuICAgICAgaW52b2tlQXJncyA9IG9wdFZhbHVlO1xyXG4gICAgICBlcnJvcktleSA9IG9wdEZpZWxkO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRvckFyaXR5ID09PSBhc3luY0FyaXR5KSB7XHJcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0FzeW5jKSB7XHJcbiAgICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xyXG4gICAgICAgIHZhbGlkYXRvckZ1bmN0aW9uID0gUHJvbWlzZS5wcm9taXNpZnkodmFsaWRhdG9yLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdG9yRnVuY3Rpb24gPSBQcm9taXNlLnByb21pc2lmeSh2YWxpZGF0b3IuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsaWRhdG9yRnVuY3Rpb24oKVxyXG4gICAgICAgIC5jYXRjaChlID0+IHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZVxyXG4gICAgICAudHJ5KCgpID0+IHZhbGlkYXRvci5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZSwgaW52b2tlQXJncykpXHJcbiAgICAgIC5jYXRjaChlID0+IHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlIGFuZCBpbnZva2UgYSBidWlsZC1pbiB2YWxpZGF0b3IuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnl0aGluZy5cclxuICAgKiBAcGFyYW0geyp9IHRlc3QgVGhlIHRlc3QgY2FzZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yVHlwZSBPbmUgb2Yga25vd24gdG8gU2VxdWVsaXplIHZhbGlkYXRvcnMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggc3BlY2lmaWMga2V5cyB0byBpbnZva2UgdGhlIHZhbGlkYXRvci5cclxuICAgKi9cclxuICBfaW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnRyeSgoKSA9PiB7XHJcbiAgICAgIC8vIENhc3QgdmFsdWUgYXMgc3RyaW5nIHRvIHBhc3MgbmV3IFZhbGlkYXRvci5qcyBzdHJpbmcgcmVxdWlyZW1lbnRcclxuICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xyXG4gICAgICAvLyBjaGVjayBpZiBWYWxpZGF0b3Iga25vd3MgdGhhdCBraW5kIG9mIHZhbGlkYXRpb24gdGVzdFxyXG4gICAgICBpZiAodHlwZW9mIHZhbGlkYXRvclt2YWxpZGF0b3JUeXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb246ICR7dmFsaWRhdG9yVHlwZX1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdmFsaWRhdG9yQXJncyA9IHRoaXMuX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcclxuXHJcbiAgICAgIGlmICghdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdKHZhbHVlU3RyaW5nLCAuLi52YWxpZGF0b3JBcmdzKSkge1xyXG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHRlc3QubXNnIHx8IGBWYWxpZGF0aW9uICR7dmFsaWRhdG9yVHlwZX0gb24gJHtmaWVsZH0gZmFpbGVkYCksIHsgdmFsaWRhdG9yTmFtZTogdmFsaWRhdG9yVHlwZSwgdmFsaWRhdG9yQXJncyB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaWxsIGV4dHJhY3QgYXJndW1lbnRzIGZvciB0aGUgdmFsaWRhdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB0ZXN0IFRoZSB0ZXN0IGNhc2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgT25lIG9mIGtub3duIHRvIFNlcXVlbGl6ZSB2YWxpZGF0b3JzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCBpcyBiZWluZyB2YWxpZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9leHRyYWN0VmFsaWRhdG9yQXJncyh0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCkge1xyXG4gICAgbGV0IHZhbGlkYXRvckFyZ3MgPSB0ZXN0LmFyZ3MgfHwgdGVzdDtcclxuICAgIGNvbnN0IGlzTG9jYWxpemVkVmFsaWRhdG9yID0gdHlwZW9mIHZhbGlkYXRvckFyZ3MgIT09ICdzdHJpbmcnICYmICh2YWxpZGF0b3JUeXBlID09PSAnaXNBbHBoYScgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzQWxwaGFudW1lcmljJyB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNNb2JpbGVQaG9uZScpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JBcmdzKSkge1xyXG4gICAgICBpZiAodmFsaWRhdG9yVHlwZSA9PT0gJ2lzSW1tdXRhYmxlJykge1xyXG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJncywgZmllbGQsIHRoaXMubW9kZWxJbnN0YW5jZV07XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbGl6ZWRWYWxpZGF0b3IgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzSVAnKSB7XHJcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFtdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJnc107XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbGlkYXRvckFyZ3MgPSB2YWxpZGF0b3JBcmdzLnNsaWNlKDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRvckFyZ3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaWxsIHZhbGlkYXRlIGEgc2luZ2xlIGZpZWxkIGFnYWluc3QgaXRzIHNjaGVtYSBkZWZpbml0aW9uIChpc251bGwpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHJhd0F0dHJpYnV0ZSBBcyBkZWZpbmVkIGluIHRoZSBTY2hlbWEuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lLlxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgYW55dGhpbmcuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZVNjaGVtYShyYXdBdHRyaWJ1dGUsIGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgaWYgKHJhd0F0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICBjb25zdCBhc3NvY2lhdGlvbiA9IF8udmFsdWVzKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpLmZpbmQoYXNzb2NpYXRpb24gPT4gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gJiYgYXNzb2NpYXRpb24uZm9yZWlnbktleSA9PT0gcmF3QXR0cmlidXRlLmZpZWxkTmFtZSk7XHJcbiAgICAgIGlmICghYXNzb2NpYXRpb24gfHwgIXRoaXMubW9kZWxJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3NvcikpIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdO1xyXG4gICAgICAgIGNvbnN0IGVyck1zZyA9IF8uZ2V0KHZhbGlkYXRvcnMsICdub3ROdWxsLm1zZycsIGAke3RoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lfS4ke2ZpZWxkfSBjYW5ub3QgYmUgbnVsbGApO1xyXG5cclxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxyXG4gICAgICAgICAgZXJyTXNnLFxyXG4gICAgICAgICAgJ25vdE51bGwgVmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkNPUkUsXHJcbiAgICAgICAgICBmaWVsZCxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgdGhpcy5tb2RlbEluc3RhbmNlLFxyXG4gICAgICAgICAgJ2lzX251bGwnXHJcbiAgICAgICAgKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuU1RSSU5HIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlRFWFQgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQ0lURVhUKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBfLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXHJcbiAgICAgICAgICBgJHtmaWVsZH0gY2Fubm90IGJlIGFuIGFycmF5IG9yIGFuIG9iamVjdGAsXHJcbiAgICAgICAgICAnc3RyaW5nIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5DT1JFLFxyXG4gICAgICAgICAgZmllbGQsXHJcbiAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgIHRoaXMubW9kZWxJbnN0YW5jZSxcclxuICAgICAgICAgICdub3RfYV9zdHJpbmcnXHJcbiAgICAgICAgKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHRoZSByZXR1cm5lZCByZXN1bHQgb2YgYSBQcm9taXNlLnJlZmxlY3QuXHJcbiAgICpcclxuICAgKiBJZiBlcnJvcnMgYXJlIGZvdW5kIGl0IHBvcHVsYXRlcyB0aGlzLmVycm9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhdHRyaWJ1dGUgbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIFRoZSBkYXRhIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbj59IHByb21pc2VJbnNwZWN0aW9ucyBvYmplY3RzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfaGFuZGxlUmVmbGVjdGVkUmVzdWx0KGZpZWxkLCB2YWx1ZSwgcHJvbWlzZUluc3BlY3Rpb25zKSB7XHJcbiAgICBmb3IgKGNvbnN0IHByb21pc2VJbnNwZWN0aW9uIG9mIHByb21pc2VJbnNwZWN0aW9ucykge1xyXG4gICAgICBpZiAocHJvbWlzZUluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XHJcbiAgICAgICAgY29uc3QgcmVqZWN0aW9uID0gcHJvbWlzZUluc3BlY3Rpb24uZXJyb3IoKTtcclxuICAgICAgICBjb25zdCBpc0J1aWx0SW4gPSAhIXJlamVjdGlvbi52YWxpZGF0b3JOYW1lO1xyXG5cclxuICAgICAgICB0aGlzLl9wdXNoRXJyb3IoaXNCdWlsdEluLCBmaWVsZCwgcmVqZWN0aW9uLCB2YWx1ZSwgcmVqZWN0aW9uLnZhbGlkYXRvck5hbWUsIHJlamVjdGlvbi52YWxpZGF0b3JBcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2lnbnMgYWxsIGVycm9ycyByZXRhaW5pbmcgdGhlIG9yaWdpbmFsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBpc0J1aWx0aW4gICAtIERldGVybWluZXMgaWYgZXJyb3IgaXMgZnJvbSBidWlsdGluIHZhbGlkYXRvci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIGVycm9yS2V5ICAgIC0gbmFtZSBvZiBpbnZhbGlkIGF0dHJpYnV0ZS5cclxuICAgKiBAcGFyYW0ge0Vycm9yfHN0cmluZ30gIHJhd0Vycm9yICAgIC0gVGhlIG9yaWdpbmFsIGVycm9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgICAgICAgLSBUaGUgZGF0YSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBmbk5hbWUgICAgICAtIE5hbWUgb2YgdGhlIHZhbGlkYXRvciwgaWYgYW55XHJcbiAgICogQHBhcmFtIHtBcnJheX0gICAgICAgICBmbkFyZ3MgICAgICAtIEFyZ3VtZW50cyBmb3IgdGhlIHZhbGlkYXRvciBbZnVuY3Rpb25dLCBpZiBhbnlcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3B1c2hFcnJvcihpc0J1aWx0aW4sIGVycm9yS2V5LCByYXdFcnJvciwgdmFsdWUsIGZuTmFtZSwgZm5BcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gcmF3RXJyb3IubWVzc2FnZSB8fCByYXdFcnJvciB8fCAnVmFsaWRhdGlvbiBlcnJvcic7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICAnVmFsaWRhdGlvbiBlcnJvcicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5GVU5DVElPTixcclxuICAgICAgZXJyb3JLZXksXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICB0aGlzLm1vZGVsSW5zdGFuY2UsXHJcbiAgICAgIGZuTmFtZSxcclxuICAgICAgaXNCdWlsdGluID8gZm5OYW1lIDogdW5kZWZpbmVkLFxyXG4gICAgICBpc0J1aWx0aW4gPyBmbkFyZ3MgOiB1bmRlZmluZWRcclxuICAgICk7XHJcblxyXG4gICAgZXJyb3JbSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FXSA9IHJhd0Vycm9yO1xyXG5cclxuICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQGRlZmluZSB7c3RyaW5nfSBUaGUgZXJyb3Iga2V5IGZvciBhcmd1bWVudHMgYXMgcGFzc2VkIGJ5IGN1c3RvbSB2YWxpZGF0b3JzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5JbnN0YW5jZVZhbGlkYXRvci5SQVdfS0VZX05BTUUgPSAnb3JpZ2luYWwnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZVZhbGlkYXRvcjtcclxubW9kdWxlLmV4cG9ydHMuSW5zdGFuY2VWYWxpZGF0b3IgPSBJbnN0YW5jZVZhbGlkYXRvcjtcclxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEluc3RhbmNlVmFsaWRhdG9yO1xyXG4iXX0=